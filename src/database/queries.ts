import type { Database } from '#root/database/index.js'
import type { User } from '@grammyjs/types'
import { startMenuCallbackData } from '#root/bot/callback-data/callbacks-start.js'
import { getBotId } from '#root/bot/helpers/botId.js'

// CREATE TABLE cases (
//     id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
//     bot_id BIGINT NOT NULL,
//     creater_id BIGINT NOT NULL,
//     topic TEXT,
//     caption TEXT,
//     videonote TEXT,
//     video TEXT,
//     photo TEXT,
//     audionote TEXT,
//     audio TEXT,
//     saved BOOLEAN DEFAULT FALSE,
// );

// CREATE TABLE users (
//     id BIGINT PRIMARY KEY,
//     bot_id BIGINT NOT NULL,
//     first_name TEXT,
//     last_name TEXT,
//     username TEXT,
//     added_at TIMESTAMPTZ DEFAULT NOW(),
//     last_update TIMESTAMPTZ DEFAULT NOW(),
//     last_state TEXT,
//     current_state TEXT
// );

export interface UserRecord {
  id: number
  bot_id: number
  first_name: string | null
  last_name: string | null
  username: string | null
  added_at: number
  last_update: number
  previous_state: string | null
  current_state: string | null
  chat_id: number
}

export function getUserById(userId: number, db: Database): Promise<UserRecord | undefined> {
  return db.query('select * from users u where u.id = $1 and u.bot_id = $2', [userId, getBotId()]).then((res) => {
    if (!res?.rows) {
      return undefined
    }
    return res.rows[0]
  })
}

export function insertNewUser(from: User, chatId: number, db: Database) {
  return db.query(
    `INSERT INTO users (id, bot_id, first_name, last_name, username, current_state, previous_state, added_at, last_update, chat_id)
         VALUES ($1, $2, $3, $4, $5, $6, $6, $7, $7, $8) on conflict (id, bot_id) do update set current_state = EXCLUDED.current_state`,
    [from.id, getBotId(), from.first_name, from.last_name, from.username, startMenuCallbackData, Date.now(), chatId],
  )
}

export function updateUserInfo(user: UserRecord, db: Database) {
  return db.query('update users set current_state = $1, previous_state = $2, last_update = $3 where id = $4 and bot_id = $5', [user.current_state, user.previous_state, user.last_update, user.id, user.bot_id])
}

export interface Case {
  id: number
  bot_id: number
  topic: string
  caption: string | null
  saved: boolean
  media_count: number
}

export async function insertNewCase(topic: string, userId: number, db: Database): Promise<number> {
  return await db.query(
    `INSERT INTO cases (bot_id, topic, creater_id) VALUES ($1, $2, $3) RETURNING id`,
    [getBotId(), topic, userId],
  ).then(res => res?.rows?.[0]?.id ?? Promise.reject(new Error('Failed to insert new case')))
}

export async function getUnsavedCaseByUser(userId: number, db: Database): Promise<Case | null> {
  const res = await db.query('SELECT c.*, count (m.id) as media_count FROM cases c LEFT JOIN (select * from media where message_id ~ \'^[0-9]+$\') m ON m.message_id::BIGINT = c.id WHERE c.creater_id = $1 AND c.saved = FALSE and c.bot_id = $2 GROUP BY c.id ORDER BY id DESC LIMIT 1', [userId, getBotId()])
  return res?.rows?.[0] ?? null
}

export function updateCaseByUser(userId: number, mediaField: 'videonote' | 'video' | 'photo' | 'audionote' | 'audio' | 'caption', fileId: string | null, db: Database) {
  if (mediaField === 'caption') {
    const queryText = `UPDATE cases SET ${mediaField} = $1 WHERE creater_id = $2 AND saved = FALSE and bot_id = $3`
    return db.query(queryText, [fileId, userId, getBotId()])
  }

  return db.query('insert into media(message_id, media_type, file_id, bot_id) values ((select id from cases where creater_id = $1 and saved = FALSE AND bot_id = $4 for update), $2, $3, $4)', [userId, mediaField, fileId, getBotId()])
}

export function deleteLastUnsavedCaseMedia(userId: number, db: Database) {
  return db.query('delete from media where id = (select id from media where bot_id = $2 message_id = (select id from cases where creater_id = $1 and saved = FALSE and bot_id = $2 order by id DESC limit 1 for update)::TEXT order by id DESC limit 1 for update)', [userId, getBotId()])
}

export function saveCaseByUser(userId: number, db: Database) {
  return db.query('UPDATE cases SET saved = TRUE WHERE creater_id = $1 AND bot_id = $2 AND saved = FALSE', [userId, getBotId()])
}

export function deleteUnsavedCasesByUser(userId: number, db: Database) {
  return db.query('DELETE FROM cases WHERE creater_id = $1 AND bot_id = $2 AND saved = FALSE', [userId, getBotId()])
}

export async function deleteCaseAndMediaByCaseId(caseId: number, db: Database) {
  await db.query('DELETE FROM media WHERE message_id = $1', [caseId.toString()])
  const rowCount = (await db.query('DELETE FROM cases WHERE id = $1', [caseId]))?.rowCount ?? 0
  if (rowCount > 0) {
    return true
  }
  throw new Error(`Deleted count = 0 for caseId = ${caseId}`)
}

export function getNextCase(db: Database, section: string, lastCaseId: number = -1): Promise<Case | null> {
  return db.query(
    'SELECT * FROM cases WHERE topic = $1 AND id > $2 AND saved = TRUE AND bot_id = $3 ORDER BY id ASC LIMIT 1',
    [section, lastCaseId, getBotId()],
  ).then((res) => {
    if (res.rows.length === 0) {
      return db.query(
        'SELECT * FROM cases WHERE topic = $1 AND saved = TRUE AND bot_id = $2 ORDER BY id ASC LIMIT 1',
        [section, getBotId()],
      ).then((res) => {
        if (res.rows.length === 0) {
          return null
        }
        return res.rows[0]
      })
    }
    return res.rows[0]
  })
}

// CREATE TABLE media (
//     id SERIAL PRIMARY KEY,
//     message_id TEXT NOT NULL,
//     media_type TEXT NOT NULL,
//     file_id TEXT NOT NULL
// );

export interface MessageMedia {
  id: number
  message_id: string
  media_type: string
  file_id: string
}

export function getMediaForMessage(messageId: string, db: Database): Promise<MessageMedia[]> {
  return db.query('SELECT * FROM media WHERE message_id = $1 and bot_id = $2', [messageId, getBotId()]).then(res => res.rows ?? [])
}
